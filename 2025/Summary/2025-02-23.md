Функция `make` создаёт массив длиной `cap` и записывает указатель на него в структуру слайса. Также она заполняет поля `len` и `cap` в этой структуре и возвращает её в виде переменной типа «слайс».

```Go
mySlice := make([]Тип, Длина, Вместимость)
```

Новый слайс может быть создан на основе уже существующего слайса или массива. Она выполняется с помощью двух скобок с двоеточием `[i:j]`, где `i` — индекс первого элемента нового слайса, а `j` — индекс следующего элемента, **не входящего** в новый слайс.

Допускается не указывать `i` и `j` (`massive[:]`) — в таком случае `i` по умолчанию будет равен 0, `j` — равен длине массива или слайса.

Таким образом, `[:]` вернёт слайс всего массива, `[:k]` — от начала и до k-го элемента, `[k:]` — от k-го элемента до конца массива.

```Go
weekTempArr := [7]int{1, 2, 3, 4, 5, 6, 7} // len 7 cap 7 : cap = максимум
workDaysSlice := weekTempArr[:5] // len 5 cap 7 : cap = максимум
weekendSlice := weekTempArr[5:] // len 2 cap 2 : cap = начиная с 5 до максимума
fromTuesdayToThursDaySlice := weekTempArr[1:4] // len 3 cap 6 : на 1 меньше макс
weekTempSlice := weekTempArr[:] // len 7 cap 7 : cap = максимум
```

### Изменение размеров слайса

Для добавления элементов к слайсу используется встроенная функция `append`. Внимание: `append` не изменяет переданный ей слайс, а создаёт новый на основе переданного.

```Go
a := []int{1, 2, 3, 4}
b := a[2:3]   // b = [3]
b = append(b, 7)
fmt.Println(a, len(a), cap(a)) // [1 2 3 7] 4 4
fmt.Println(b, len(b), cap(b)) // [3 7] 2 2
b = append(b, 8, 9, 10)
b[0] = 11
fmt.Println(a, len(a), cap(a)) // [1 2 3 7] 4 4
fmt.Println(b, len(b), cap(b)) // [11 7 8 9 10] 5 6
```

Слайс `a` изменился после выполнения первого `append`, т.к. дело в механике `append`: если ёмкость слайса позволяет разместить добавляемые элементы (то есть разница между длиной слайса и его ёмкостью больше или равна количеству размещаемых элементов), то `append` не копирует данные, а ссылается на ту же область памяти, что и `a`.

Если же ёмкость слайса не позволяет разместить эти элементы, то создаётся новый базовый массив подходящего размера, в него копируются все элементы переданного слайса и добавляются новые. Именно поэтому в примере после второго `append` слайс `b` ссылается на новый базовый массив. Исходя из чего: пока не превышает `cap` - используется массив старый, если превышает, то создаётся новый.

```Go
s := make([]int, 4, 7) // [0 0 0 0], len = 4 cap = 7
// 1. Создаём слайс s с базовым массивом на 7 элементов. 
// Четыре первых элемента будут доступны в слайсе.

slice1 := append(s[:2], 2, 3, 4)  
fmt.Println(s, slice1) // [0 0 2 3] [0 0 2 3 4]
// 2. Берём слайс из первых двух элементов s и добавляем к ним три элемента.
// Так как суммарная длина полученного слайса (len == 5) меньше ёмкости s[:2] (cap == 7), 
// то базовый массив остаётся прежним.
// Слайс s тоже изменился, но его длина осталась прежней

slice2 := append(s[1:2], 7) 
fmt.Println(s, slice1, slice2) // [0 0 7 3] [0 0 7 3 4] [0 7]
// 3. Здесь также базовый массив остаётся прежним, изменились все три слайса

slice3 := append(s, slice1[1:]...)
fmt.Println(len(slice3), cap(slice3))  // 8 14
// 4. Длина s и slice1[1:] равна 4, длина нового слайса будет равна 8,  
// что больше ёмкости базового массива.
// Будет создан новый базовый массив ёмкостью 14,
// ёмкость нового базового массива подбирается автоматически 
// и зависит от текущего размера и количества добавленных элементов

// 5. Легко проверить, что slice3 ссылается на новый базовый массив
s[1] = 99
fmt.Println(s, slice1, slice2, slice3) 
// [0 99 7 3] [0 99 7 3 4] [99 7] [0 0 7 3 0 7 3 4]
```

![[{9B3B9F5C-EA90-406B-B438-CFFD6CA40717}.png]]

Здесь не очень понятно, будут ли новые слайсы ссылаться на тот же базовый массив или отправят свои копии в новый массив. Поэтому на практике функцию `append` рекомендуют лишь для присвоения слайса самому себе: `s = append(s, b)`.

==Старайтесь избегать ситуаций, когда на базовый массив ссылается несколько слайсов и происходит добавление или изменение элементов.==
## Присваивание слайса и передача в функции

При передаче слайса в аргументы функции структура слайса копируется в локальную переменную внутри функции. Это позволяет изменить данные внутри слайса, переданного в функцию. Но если нужно добавить или удалить элементы из слайса, то эти изменения затронут только локальную переменную слайса.

```Go
s := []int{5, 4, 1, 3, 2}
sort.Ints(s)
fmt.Println(s) // [1 2 3 4 5]
```

Она не меняет размер и ёмкость слайса, поэтому может спокойно работать с ним.
## Копирование слайсов

Для копирования элементов из одного слайса в другой применяется функция `copy([]T dest, []T src)`, где `dest` — это слайс-приёмник, а `src` — слайс-источник. Эта функция только перезаписывает элементы, поэтому количество скопированных элементов будет равно меньшей длине из двух слайсов.

```Go
var dest []int
dest2, dest3 := make([]int, 3),  make([]int, 5)
src := []int{1, 2, 3, 4}
copy(dest, src)
copy(dest2, src)
copy(dest3, src)
fmt.Println(dest, dest2, dest3, src ) // [] [1 2 3] [1 2 3 4 0] [1 2 3 4]
```

### Полезные приёмы для работы со слайсами

Удаление последнего элемента слайса:

```Go
s := []int{1, 2, 3}
if len(s) != 0 { // защищаемся от паники
    s = s[:len(s)-1]
}
fmt.Println(s) // [1 2]
```

Удаление первого элемента слайса:

```Go
s := []int{1,2,3}
if len(s) != 0 { // защищаемся от паники
    s = s[1:]
} 
fmt.Println(s) // [2 3]
```

Удаление элемента слайса с индексом `i`:

```Go
s := []int{1, 2, 3, 4, 5}
i := 2
if len(s) != 0 && i < len(s) { // защищаемся от паники
	s = append(s[:i], s[i+1:]...) // s[:i] = 1,2 // s[i+1:] = 4,5
}
fmt.Println(s) // [1 2 4 5]
```

`...` - оператор распаковки, используются, когда нужно передать элементы среза как отдельные аргументы в функцию, которая принимает переменное количество аргументов (variadic function), например, `append`.

Сравнение двух слайсов:

```Go
rus := "Нi, Sеrеgа" // H,e,a = русские буквы
eng := "Hi, Serega"
fmt.Println(reflect.DeepEqual(rus, eng))
```

# Задание в конце главы:

Создайте слайс и заполните его числами от 1 до 100. Оставьте в слайсе первые и последние 10 элементов и разверните слайс в обратном порядке. Подумайте, можно ли подобным образом развернуть строку?
```Go
package main

import "fmt"

func main() {
    dim := 100
    s := make([]int, 0, dim)
    // заполняем слайс числами
    for i := 0; i < dim; i++ {
        s = append(s, i+1)
    }
    // оставляем первые и последние 10 элементов
    s = append(s[:10], s[dim-10:]...)
    dim = len(s)
    // разворачиваем слайс
    for i := range s[:dim/2] {
        s[i], s[dim-i-1] = s[dim-i-1], s[i]
    }
    fmt.Println(s)
}

// Разернуть строку таким образом не получится, так как строка — неизменяемый тип данных. 
// Строку можно преобразовать к слайсу байт ([]byte), но это опасно, если строка содержит Unicode-символы
// Лучше создать слайс рун из строки и развернуть его
// Например, так:

func main() {
    input := "The quick brown 狐 jumped over the lazy 犬"
    // Get Unicode code points. 
    n := 0
    // создаём слайс рун 
    runes := make([]rune, len(input))
    // добавляем руны в слайс
    for _, r := range input {
        runes[n] = r
        n++
    }
    // убираем лишние нулевые руны
    runes = runes[0:n]
    // разворачиваем
    for i := 0; i < n/2; i++ {
        runes[i], runes[n-1-i] = runes[n-1-i], runes[i]
    }
    // преобразуем в строку UTF-8. 
    output := string(runes)
    fmt.Println(output)
}
```

Я смог сделать только 1/2. Гуглил как перевернуть слайс, а также после того как увидел ответ:

```Go
package main

import "fmt"

func main() {
	s := make([]int, 100)
	for i := 0; i < len(s); i++ {
		s[i] = i + 1
	}
	trim := append(s[:10], s[90:]...)
	reversed := []int{}
	for i := len(trim) - 1; i >= 0; i-- {
		reversed = append(reversed, trim[i])
	}
	fmt.Println(reversed)
}
```
