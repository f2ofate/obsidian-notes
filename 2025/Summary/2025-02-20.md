# Указатели

Все данные программы, включая переменные, хранятся в памяти компьютера. Каждая переменная имеет адрес в виде целого положительного числа. 

Если нужно передать переменную из одной части программы в другую, хватит обычного копирования:

```Go
a := 5
b := a
fmt.Println("b =", &b, "a =", &a) // b = 0xc00008e0b0 a = 0xc00008e098
```

Значение переменной `а` полностью скопировалось в `b`.

Физически указатель — это ячейка памяти, хранящая адрес ячейки, на которую «смотрит» указатель. После создания указатель не «смотрит» ни на одну ячейку памяти в компьютере и имеет нулевое значение. Оно выглядит как `nil`.

Для того чтобы присвоить указателю значение (адрес какой-либо переменной), используется операция взятия адреса `&`:

```Go
var p *int
fmt.Println("p =", p) // p = <nil>
a := 5
p = &a
fmt.Println("p =", p, "a =", &a) // p = 0xc00000a110 a = 0xc00000a110
```

В Go константы не имеют адреса, потому что они не хранятся в памяти как переменные. Константы в Go представляют собой значения, которые известны на этапе компиляции, и компилятор может оптимизировать их использование.

Тип переменной, на которую создаётся указатель, должен соответствовать типу указателя. Литералы композитных типов создают в памяти переменную соответствующего типа, поэтому указатель можно создать вот так:

```Go
  type A struct {
      IntField int
  }
  // Литерал А{} создаёт в памяти переменную типа А. Затем от неё берётся указатель
  p := &A{ 
      IntField: 10,
  }
// В качестве параметра ей передаётся тип, а возвращается указатель на новую переменную соответствующего типа.
 p := new(A) //  то же самое, что и &A{} 
```

Тип указателя на указатель будет записываться как `**int` и т.д.
Что бы получить/изменить значение, хранящееся по указателю применяют оператор **разыменования** (**dereference**) `*`.

```Go
var p *int
a := 5
p = &a
c := &p
fmt.Println("p =", *p, "a =", a, "c =", **c) // если сделать *c, то даст адресс a
// Вывод: p = 5 a = 5 c = 5
```