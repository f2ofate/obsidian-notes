## Two Sum  || - Input Array Is Sorted

Задача заключатся в том что бы найти какие элементы массива при сложении дадут `target`. Проще всего решить вложенным циклом, но это `O(n^2)`, ещё есть предположение по решению за `O(n)`, если складывать в мапу и проверять там, но там по памяти n из-за чего не очень круто, а также я не совсем понимаю как его решать =) Наиболее быстрым оказывается метод с 2мя указателями из-за того, что по сложности это `O(n)`, а по памяти `O(1)`

**Суть алгоритма:**

Нужно поставить указатели на начло и конец, после чего сверяем если сумма указателей меньше `target`, то нужно увеличивать слева, если больше, то уменьшать справа. Таким образом либо решение найдётся и добавится в массив, который будет `return`, либо указатели встретятся и цикл закончится. 


```Go
func twoSum(numbers []int, target int) []int {
	left := 0
	right := len(numbers) - 1
	out := []int{}
	for left < right {
		current := numbers[left] + numbers[right]
		switch {
		case current == target:
			out = append(out, left+1, right+1)
			return out
		case current < target:
			left++
		case current > target:
			right--
		}
	}
	return out
}

func main() {
	numbers1 := []int{2, 7, 11, 15}
	numbers2 := []int{2, 3, 4}
	numbers3 := []int{-1, 0}
	fmt.Println(twoSum(numbers1, 9))
	fmt.Println(twoSum(numbers2, 6))
	fmt.Println(twoSum(numbers3, -1))
}
```

# Заметка

## Как считать расход по памяти?:

По выделению памяти. Допустим в данном случае при увеличении размера массива, кол-во указателей остаётся неизменным, если бы в массиве было 100.000 элементов, то указателей всё равно было бы 2 из чего следует, что расход по памяти на алгоритм = `O(1)`