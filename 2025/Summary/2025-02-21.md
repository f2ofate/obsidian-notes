## Указатели и структуры

Для указателей на структуры в Go есть возможность неявного разыменования при доступе к полям структуры.

```Go
type A struct {
    IntField int
}

p := &A{}
p.IntField = 42 // вместо (*p).IntField = 42
```

Важно! когда вы выводите значение указателя на структуру с помощью `fmt.Println`, пакет `fmt` специальным образом форматирует вывод, чтобы отобразить содержимое структуры, на которую указывает указатель, наглядная разница:

```Go
fmt.Println(p) // &{42}
println(p)     // 0xc00008e098
```

### Когда стоит использовать указатели

1) Когда нужно изменить значение переменной из вызываемой функции ибо если передать переменную по значению, все модификации внутри функции применятся к локальной копии и оставят исходную переменную неизменной.
```Go
  incrementCopy := func(i int) {
      i++
  }

  increment := func(i *int) {
      (*i)++
  }

  i := 42

  incrementCopy(i)
  fmt.Println(i) // 42

  increment(&i)
  fmt.Println(i) // 43
  
```

2) Когда нужно подчеркнуть, что значение может отсутствовать. Например, есть функция, которая возвращает запись о пользователе `type User struct{...}` по его идентификатору. Результат-указатель даёт понять, что не по всем идентификаторам может быть найден пользователь. Пример функции с такой сигнатурой:

```Go
func FindUser(id int) *User
```

3) Когда вы работаете с ресурсами вроде файловых дескрипторов или сокетов. Копирование таких переменных может быть связано с исчерпанием системных ресурсов или вообще не производиться.

4) Когда вы работаете с большими переменными и на копирование по стеку затрачивается больше ресурсов, чем на сборку мусора от указателей.

### Когда не стоит использовать указатели

1) Когда хочется ускорить приложение и кажется, что копирование структур — слишком дорогая операция. До тех пор, пока нет тестов, однозначно показывающих, что указатели повышают производительность, лучше не пытаться оптимизировать.
2) Задумываться о замене передачи по значению на передачу по указателю стоит, когда размер структуры достигает порядка сотен байт.
3)  Когда множество указателей в памяти сильно нагружают сборщик мусора. Такое может произойти, к примеру, при создании собственной in-memory базы данных.

# Задание в конце:

Перед вами неполный код программы, которая считает, сколько строк пользователь ввёл в консоль, и после ввода каждой новой строки выводит общее количество на экран. Напишите реализацию функции `f`.

```Go
package main

import (
    "bufio"
    "fmt"
    "os"
)

func main() {
    // Получаем читателя пользовательского ввода
    reader := bufio.NewReader(os.Stdin)
    fmt.Println("Interaction counter")

    cnt := 0
    for {
        fmt.Print("-> ")
        _, err := reader.ReadString('\n')
        if err != nil {
            panic(err)
        }

        f(&cnt)

        fmt.Printf("User input %d lines\n", cnt)
    }
}
```

Ответ: 
```spoiler-block
// Мой:
func f(p *int) int {
    *p += 1
    return *p
}

// Курс:
func f(p *int) int {
    *p++
    return *p
}
```

 И то и то работает, но я забыл про то, что можно использовать ++