## ООП

**Interface** - даёт возможность задать ограничения на тип в виде списка методов, которые тот должен реализовывать. Достаточно реализовать набор методов у типа, чтобы он начал автоматически удовлетворять всем интерфейсам с аналогичными сигнатурами методов:

```Go
type Stringer interface {
    String() string
}

type myType int

// myType реализует интерфейс Stringer 
func (t myType) String() string {
    // представление типа myType в виде строки
}
```

| В других языках                                                                                                                                                  | В Golang:                                                                                                                                                                                                                       |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Абстракция** — возможность определить характеристики (свойства и методы) объекта, которые полностью описывают его возможности.                                 | В Go нет классов, но структуры с методами служат им неплохой заменой.                                                                                                                                                           |
| **Инкапсуляция** — возможность скрыть реализацию объекта, предоставив пользователю некую спецификацию (интерфейс) взаимодействия с ним.                          | Go даёт возможность задать область видимости (публичные/приватные) методов структур и позволяет спрятать реализацию.                                                                                                            |
| **Наследование** — возможность создания производных от родительского объекта, которые будут расширять или изменять свойства и поведение родителя.                | Go не реализует в полной мере механизм наследования, но есть встраивание — можно создавать типы на основе существующих.                                                                                                         |
| **Полиморфизм** — возможность одному и тому же фрагменту кода работать с разными типами данных. Это происходит, когда объект может вести себя как другой объект. | В Go нет полиморфизма в классическом понимании, однако похожие действия можно реализовать с помощью интерфейсов. Интерфейс определяет список методов, которые должен реализовывать тип, чтобы удовлетворять данному интерфейсу. |
Go считается мультипарадигмальным, потому что помимо частичной реализации парадигм ООП  частично реализует парадигмы функционального программирования:

- **Функции высшего порядка** — функции, которые могут в аргументах принимать другие функции и возвращать функции в качестве результата. В Go функции рассматриваются как значения и могут передаваться в другие функции, возвращаясь в виде результата.
- **Замыкания**. Go позволяет определять и использовать функции, которые ссылаются на переменные своей родительской функции.
- **Чистые функции**. В Go можно определять функции, которые зависят только от входящих аргументов и не влияют на глобальное состояние.
- **Рекурсия**. Как и в большинстве языков, в Go можно применять рекурсивные вызовы функций.
- **Ленивые вычисления**. В Go нет поддержки ленивых (отложенных) вычислений.
- **Иммутабельность переменных**. В Go переменные могут изменять своё значение, поэтому иммутабельность (неизменяемость) переменных отсутствует.

## Обработка ошибок

В отличии от других языков, где ошибки обрабатывают с помощью механизма **exception** - в GO функции могут возвращать тип **error**:
```Go
package main

import "fmt"

func div(a, b int) (int, error) {
    if b == 0 {
        return 0, fmt.Errorf("делитель равен 0")
    }
    return a / b, nil
}

func main() {
    d, err := div(10, 0)
    if err != nil {
        fmt.Println(err)
    } else {
        fmt.Printf("d = %d", d)
    }
}
```

Так как возможность возникновения ошибки при выполнении функции отражена непосредственно в её сигнатуре (последнее возвращаемое значение имеет тип `error`), пользователь, который обращается к этой функции, вынужден всегда обрабатывать или игнорировать ошибку явно, иначе код не скомпилируется.

## Panic

**Panic** - выбрасывается только тогда, когда исполняющий код попадает в нестандартную ситуацию, которую невозможно обработать. Go даёт возможность перехватывать и обрабатывать панику. Для этого используется конструкция `defer` и встроенная функция `recover`.

`defer` — это ещё одна необычная концепция языка, которая выполняет блоки кода при выходе из функции, например, чтобы закрывать файлы по завершении работы с ними. `defer` выполняется даже в случае паники, когда происходит аварийное завершение функций.

```Go
func foo() {
    // паникуем
    panic("unexpected!")
}
//...
    // выполняется после срабатывания паники
    defer func() {
        if r := recover(); r != nil {
            // обработка паники, в переменной r будет лежать строка "unexpected"
        }
    }()
    // внутри foo срабатывает паника
    foo()
```

![[{BAD39EAF-33B3-48F9-8CF2-8A6BB1C87BC1}.png]]

Аварийную ситуацию можно создать самостоятельно, вызвав функцию `panic` с параметром любого типа.

`recover` — функция, которая позволяет восстановить выполнение программы в случае паники. Если на момент вызова `recover` произошла аварийная ситуация, то `recover` завершает её и возвращает значение ошибки (аргумент при вызове `panic`). Если аварийной ситуации не было, `recover` ничего не делает и возвращает `nil`.

## Какие элементы многопоточности есть в Go?

**Горутина** — это легковесный поток, который занимает гораздо меньше памяти, чем поток ОС. Среда выполнения Go может выполнять несколько горутин на одном потоке операционной системы и быстро переключаться с выполнения одной горутины на другую благодаря их малому размеру. Вытесняющий планировщик старается равномерно распределять процессорное время между горутинами.

**Каналы** — это второй ключевой элемент в многопоточности на Go. Каналы не только дают возможность потокам обмениваться данными, но и служат для синхронизации их работы. Одна горутина может записать данные в канал, а другая горутина прочитать их. Кроме этого, стандартная библиотека имеет дополнительные примитивы синхронизации потоков.