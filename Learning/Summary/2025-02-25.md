## Использование в циклах range

```Go
m := make(map[string]string)
m["foo"] = "bar"
m["bazz"] = "yup"
for k, v := range m {
    // k будет перебирать ключи,
    // v — соответствующие этим ключам значения
    fmt.Printf("Ключ %v, имеет значение %v \n", k, v)
}
```

Go позволяет добавлять и удалять значения в `map` прямо внутри цикла, в процессе итерации. Удалённые ключи гарантированно не попадут в последующие итерации. С добавленными ключами таких гарантий нет. Новый ключ может попасть в последующие итерации, а может и не попасть.
## Конкурентный (concurrent) доступ

При запуске горутин помните, что ни один встроенный тип в Go (кроме `chan`) не защищён для доступа из нескольких потоков, и `map` не исключение.

Для безопасного использования `map` из нескольких потоков должны применяться механизмы защиты, иначе возможно повреждение данных или состояние гонки. Недавно в стандартной библиотеке [появился](https://golang.org/pkg/sync/#Map) потокобезопасный вариант ассоциативного массива, эквивалент `map`, которым можно пользоваться в многопоточной среде. Механизмы защиты в этот тип уже встроены.
# Задания:

Сделайте `map` для хранения прейскуранта в рублях:

- хлеб — 50,
- молоко — 100,
- масло — 200,
- колбаса — 500,
- соль — 20,
- огурцы — 200,
- сыр — 600,
- ветчина — 700,
- буженина — 900,
- помидоры — 250,
- рыба — 300,
- хамон — 1500.

1. Выведите перечень деликатесов — продуктов дороже 500 рублей.
2. Заказ выдан слайсом `[]string{"хлеб", "буженина", "сыр", "огурцы"}`. Посчитайте стоимость заказа.

Ответ:

```Go
items := map[string]int{"хлеб": 50, "молоко": 100, "масло": 200, "колбаса": 500, "соль": 20, "огурцы": 200, "сыр": 600, "ветчина": 700, "буженина": 900, "помидоры": 250, "рыба": 300, "хамон": 1500}
major := []string{}
order := []string{"хлеб", "буженина", "сыр", "огурцы"}
total := 0
for k, v := range items {
	if v > 500 {
		major = append(major, k)
	}
}
for _, v := range order { // Help
	total += items[v]    
}
fmt.Println(major, total)
```

Нужна была помощь со вторым. Я забыл, что можно перебирать слайс, а после выведенное значение подставить в качестве `key` для мапы.

Дан массив целых чисел A и целое число k. Нужно найти и вывести индексы пары чисел, сумма которых равна k. Если таких чисел нет, то вернуть пустой слайс. Индексы можно вернуть в любом порядке.

```Go
// Мой
a := []int{2, 4, 5, 8, 10, 12, 14, 15, 16, 17, 19, 21, 24, 25}
k := 14
answer := []int{}
for i := 0; i < len(a); i++ {
	for j := 1; j < len(a)-1; j++ {
		if a[i]+a[j] == k {
			answer = append(answer, i, j)
		}
	}
}
fmt.Println(answer)

// Хуяндекс
func find(arr []int, k int) []int {
	m := make(map[int]int)
	for i, a := range arr {
		if j, ok := m[k-a]; ok { 
			return []int{i, j}
		}
		m[a] = i
	}
	return nil
}
```

Дан слайс, напишите функцию, которая убирает дубликаты:
```Go
input := []string{
	"cat",
	"dog",
	"bird",
	"dog",
	"parrot",
	"cat",
}

func RemoveDuplicates(input []string) []string
```