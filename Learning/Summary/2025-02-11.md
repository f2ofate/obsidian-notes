# Многопоточность.

**Поток выполнения (native/kernel thread)** — это часть процесса, в которой инструкции могут выполняться независимо и иметь доступ к общим ресурсам. За управление потоками отвечает планировщик ОС.

**Многопоточность** — свойство железа и софта, при котором несколько потоков могут выполняться параллельно, не мешая друг другу.

Для эффективного использования доступной вычислительной мощности и потоков ввода/вывода Go оперирует несколькими системными потоками, распределяя между ними ещё больше своих собственных легковесных потоков со стратегией `m*n`. То есть на одном системном потоке могут исполняться несколько горутин. Если системный поток блокирован ожиданием ввода/вывода или перегружен, диспетчер Go может перенести горутину на свободный. Если захваченных системных потоков недостаточно, диспетчер Go может потребовать у системы новых.

## Как в Go реализовали многопоточность?

Существуют разные модели многопоточных вычислений, среди которых архитекторы Go выбрали модель **CSP (Communicating Sequential Processes)**, описанную Энтони Хоаром в одноимённой статье. В этой модели программа представляет собой множество одновременно работающих **подзадач**, которые общаются между собой, передавая сообщения через **каналы связи**.

![[chapter0_picture3_1654014855.png]]

Горутина в Go - это подзачдача. Горутины живут в прослойке между программой и средой выполнения под названием **runtime**. Также рантайм отвечает за организацию конкурентного доступа множества горутин к процессорному времени. Его задача - распределить процессорное время так, чтобы каждая горутина смогла поработать хотя бы какое-то время, прежде чем управление перейдёт к следующей.

Горутины могут взаимодействовать между собой, обмениваясь сообщениям при помощи канала связи в виде **channel (канал)**. Канал - это подобие туннеля в который одна горутиная может положить значение, а другая - это значение оттуда вытащить и что-то с ним сделать.

![[{33541DFB-2DF3-4140-B19A-8DE73B9F0E9B}.png]]


